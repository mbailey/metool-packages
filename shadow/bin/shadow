#!/usr/bin/env bash
set -o nounset -o pipefail -o errexit
#
# shadow - Manage shadow repositories for private content alongside public repos
#
# This is the main entry point for the shadow repository system.
# Subcommands are stored in libexec/ and called based on the first argument.

# Get absolute path to script, even when called via symlink
command -v realpath &> /dev/null || {
    echo "Error: 'realpath' is required but not found. Please install 'coreutils' (e.g. 'brew install coreutils' on macOS)." >&2
    exit 1
}
SCRIPT_PATH="$(realpath "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
LIBEXEC_DIR="$SCRIPT_DIR/../libexec"

# Color support
if [[ -n "${NO_COLOR:-}" ]] || [[ ! -t 1 ]]; then
    GREEN=""
    YELLOW=""
    NC=""
else
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color
fi

# Function to show usage
show_usage() {
    cat << EOF
shadow - Manage shadow repositories for private content

Usage: shadow <command> [arguments]

Commands:
    add         Create shadow repository structure for current repo
    extract     Extract file/directory from main repo to shadow repo
    import      Import content from shadow repo back to main repo
    sync        Sync shadow repo structure with main repo
    sync-repos  Sync content between main and shadow repositories
    sync-excludes Update .git/info/exclude with shadow paths
    status      Show shadow repository linkage status
    find        Find shadow repositories for current project

Examples:
    shadow status                           # Show current shadow linkage
    shadow extract docs/private ../shadow   # Extract to shadow repo
    shadow import docs/private              # Import back to main repo
    shadow sync                            # Update all shadow symlinks

For more help on a specific command:
    shadow <command> -h

EOF
}

# Check if no arguments provided
if [[ $# -eq 0 ]]; then
    show_usage
    exit 0
fi

# Get the subcommand
SUBCOMMAND="$1"
shift

# Handle help flags
if [[ "$SUBCOMMAND" == "-h" ]] || [[ "$SUBCOMMAND" == "--help" ]] || [[ "$SUBCOMMAND" == "help" ]]; then
    show_usage
    exit 0
fi

# Check if libexec directory exists
if [[ ! -d "$LIBEXEC_DIR" ]]; then
    echo "Error: libexec directory not found at $LIBEXEC_DIR"
    exit 1
fi

# Construct path to subcommand
SUBCOMMAND_PATH="$LIBEXEC_DIR/shadow-$SUBCOMMAND"

# Check if subcommand exists
if [[ ! -x "$SUBCOMMAND_PATH" ]]; then
    echo -e "${YELLOW}Error: Unknown command '$SUBCOMMAND'${NC}"
    echo ""
    show_usage
    exit 1
fi

# Execute the subcommand with remaining arguments
exec "$SUBCOMMAND_PATH" "$@"